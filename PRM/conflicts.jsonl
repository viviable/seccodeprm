{"step": "\terr = handle->h_err;", "dataset1_info": {"data_index": 1170, "step_index": 6, "label": 0, "code": "\terr = handle->h_err;"}, "dataset2_info": {"data_index": 552, "step_index": 2, "label": 1, "code": "\terr = handle->h_err;"}}
{"step": "\terr = handle->h_err;", "dataset1_info": {"data_index": 1170, "step_index": 2, "label": 1, "code": "\terr = handle->h_err;"}, "dataset2_info": {"data_index": 552, "step_index": 7, "label": 0, "code": "\terr = handle->h_err;"}}
{"step": "\terr = handle->h_err;", "dataset1_info": {"data_index": 1171, "step_index": 6, "label": 0, "code": "\terr = handle->h_err;"}, "dataset2_info": {"data_index": 552, "step_index": 2, "label": 1, "code": "\terr = handle->h_err;"}}
{"step": "\terr = handle->h_err;", "dataset1_info": {"data_index": 1171, "step_index": 2, "label": 1, "code": "\terr = handle->h_err;"}, "dataset2_info": {"data_index": 552, "step_index": 7, "label": 0, "code": "\terr = handle->h_err;"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1304, "step_index": 13, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1304, "step_index": 13, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1304, "step_index": 22, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1304, "step_index": 22, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1305, "step_index": 13, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1305, "step_index": 13, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1305, "step_index": 22, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 1305, "step_index": 22, "label": 0, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 408, "step_index": 21, "label": 1, "code": "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"}}
{"step": "\tht->nTableSize = zend_hash_check_size(nSize);", "dataset1_info": {"data_index": 1650, "step_index": 1, "label": 0, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}, "dataset2_info": {"data_index": 523, "step_index": 3, "label": 1, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}}
{"step": "\tht->nTableSize = zend_hash_check_size(nSize);", "dataset1_info": {"data_index": 1650, "step_index": 3, "label": 1, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}, "dataset2_info": {"data_index": 523, "step_index": 1, "label": 0, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}}
{"step": "\tht->nTableSize = zend_hash_check_size(nSize);", "dataset1_info": {"data_index": 1651, "step_index": 1, "label": 0, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}, "dataset2_info": {"data_index": 523, "step_index": 3, "label": 1, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}}
{"step": "\tht->nTableSize = zend_hash_check_size(nSize);", "dataset1_info": {"data_index": 1651, "step_index": 3, "label": 1, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}, "dataset2_info": {"data_index": 523, "step_index": 1, "label": 0, "code": "\tht->nTableSize = zend_hash_check_size(nSize);"}}
{"step": "      CheckNumberCompactPixels;", "dataset1_info": {"data_index": 1804, "step_index": 9, "label": 0, "code": "      CheckNumberCompactPixels;"}, "dataset2_info": {"data_index": 439, "step_index": 7, "label": 1, "code": "      CheckNumberCompactPixels;"}}
{"step": "      CheckNumberCompactPixels;", "dataset1_info": {"data_index": 1804, "step_index": 7, "label": 1, "code": "      CheckNumberCompactPixels;"}, "dataset2_info": {"data_index": 439, "step_index": 9, "label": 0, "code": "      CheckNumberCompactPixels;"}}
{"step": "      CheckNumberCompactPixels;", "dataset1_info": {"data_index": 1805, "step_index": 9, "label": 0, "code": "      CheckNumberCompactPixels;"}, "dataset2_info": {"data_index": 439, "step_index": 7, "label": 1, "code": "      CheckNumberCompactPixels;"}}
{"step": "      CheckNumberCompactPixels;", "dataset1_info": {"data_index": 1805, "step_index": 7, "label": 1, "code": "      CheckNumberCompactPixels;"}, "dataset2_info": {"data_index": 439, "step_index": 9, "label": 0, "code": "      CheckNumberCompactPixels;"}}
{"step": "\tjas_tvparser_destroy(tvp);", "dataset1_info": {"data_index": 1846, "step_index": 4, "label": 0, "code": "\tjas_tvparser_destroy(tvp);"}, "dataset2_info": {"data_index": 554, "step_index": 6, "label": 1, "code": "\tjas_tvparser_destroy(tvp);"}}
{"step": "\tjas_tvparser_destroy(tvp);", "dataset1_info": {"data_index": 1846, "step_index": 6, "label": 1, "code": "\tjas_tvparser_destroy(tvp);"}, "dataset2_info": {"data_index": 554, "step_index": 4, "label": 0, "code": "\tjas_tvparser_destroy(tvp);"}}
{"step": "\tjas_tvparser_destroy(tvp);", "dataset1_info": {"data_index": 1847, "step_index": 4, "label": 0, "code": "\tjas_tvparser_destroy(tvp);"}, "dataset2_info": {"data_index": 554, "step_index": 6, "label": 1, "code": "\tjas_tvparser_destroy(tvp);"}}
{"step": "\tjas_tvparser_destroy(tvp);", "dataset1_info": {"data_index": 1847, "step_index": 6, "label": 1, "code": "\tjas_tvparser_destroy(tvp);"}, "dataset2_info": {"data_index": 554, "step_index": 4, "label": 0, "code": "\tjas_tvparser_destroy(tvp);"}}
{"step": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", "dataset1_info": {"data_index": 1860, "step_index": 0, "label": 1, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}, "dataset2_info": {"data_index": 431, "step_index": 0, "label": 0, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}}
{"step": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", "dataset1_info": {"data_index": 1860, "step_index": 0, "label": 1, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}, "dataset2_info": {"data_index": 431, "step_index": 0, "label": 0, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}}
{"step": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", "dataset1_info": {"data_index": 1861, "step_index": 0, "label": 1, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}, "dataset2_info": {"data_index": 431, "step_index": 0, "label": 0, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}}
{"step": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)", "dataset1_info": {"data_index": 1861, "step_index": 0, "label": 1, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}, "dataset2_info": {"data_index": 431, "step_index": 0, "label": 0, "code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)"}}
{"step": "  fptr_orig = io_get_open_fptr(mrb, orig);", "dataset1_info": {"data_index": 2060, "step_index": 3, "label": 0, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}, "dataset2_info": {"data_index": 598, "step_index": 2, "label": 1, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}}
{"step": "  fptr_orig = io_get_open_fptr(mrb, orig);", "dataset1_info": {"data_index": 2060, "step_index": 1, "label": 1, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}, "dataset2_info": {"data_index": 598, "step_index": 4, "label": 0, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}}
{"step": "  fptr_orig = io_get_open_fptr(mrb, orig);", "dataset1_info": {"data_index": 2061, "step_index": 3, "label": 0, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}, "dataset2_info": {"data_index": 598, "step_index": 2, "label": 1, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}}
{"step": "  fptr_orig = io_get_open_fptr(mrb, orig);", "dataset1_info": {"data_index": 2061, "step_index": 1, "label": 1, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}, "dataset2_info": {"data_index": 598, "step_index": 4, "label": 0, "code": "  fptr_orig = io_get_open_fptr(mrb, orig);"}}
{"step": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;", "dataset1_info": {"data_index": 2188, "step_index": 11, "label": 1, "code": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;"}, "dataset2_info": {"data_index": 589, "step_index": 9, "label": 0, "code": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;"}}
{"step": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;", "dataset1_info": {"data_index": 2189, "step_index": 11, "label": 1, "code": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;"}, "dataset2_info": {"data_index": 589, "step_index": 9, "label": 0, "code": "  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;"}}
{"step": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "dataset1_info": {"data_index": 2210, "step_index": 2, "label": 0, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}, "dataset2_info": {"data_index": 577, "step_index": 7, "label": 1, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}}
{"step": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "dataset1_info": {"data_index": 2210, "step_index": 6, "label": 1, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}, "dataset2_info": {"data_index": 577, "step_index": 3, "label": 0, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}}
{"step": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "dataset1_info": {"data_index": 2211, "step_index": 2, "label": 0, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}, "dataset2_info": {"data_index": 577, "step_index": 7, "label": 1, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}}
{"step": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "dataset1_info": {"data_index": 2211, "step_index": 6, "label": 1, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}, "dataset2_info": {"data_index": 577, "step_index": 3, "label": 0, "code": "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 2279, "step_index": 7, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  Quantum\n    index;", "dataset1_info": {"data_index": 2279, "step_index": 8, "label": 0, "code": "  Quantum\n    index;"}, "dataset2_info": {"data_index": 408, "step_index": 7, "label": 1, "code": "  Quantum\n    index;"}}
{"step": "  Quantum\n    index;", "dataset1_info": {"data_index": 2279, "step_index": 8, "label": 0, "code": "  Quantum\n    index;"}, "dataset2_info": {"data_index": 408, "step_index": 7, "label": 1, "code": "  Quantum\n    index;"}}
{"step": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {", "dataset1_info": {"data_index": 2502, "step_index": 3, "label": 0, "code": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {"}, "dataset2_info": {"data_index": 644, "step_index": 4, "label": 1, "code": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {"}}
{"step": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {", "dataset1_info": {"data_index": 2503, "step_index": 3, "label": 0, "code": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {"}, "dataset2_info": {"data_index": 644, "step_index": 4, "label": 1, "code": "\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {"}}
{"step": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n", "dataset1_info": {"data_index": 3324, "step_index": 3, "label": 1, "code": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n"}, "dataset2_info": {"data_index": 400, "step_index": 10, "label": 0, "code": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n"}}
{"step": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n", "dataset1_info": {"data_index": 3325, "step_index": 3, "label": 1, "code": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n"}, "dataset2_info": {"data_index": 400, "step_index": 10, "label": 0, "code": "\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n"}}
{"step": "    quantum_info=DestroyQuantumInfo(quantum_info);", "dataset1_info": {"data_index": 3414, "step_index": 55, "label": 0, "code": "    quantum_info=DestroyQuantumInfo(quantum_info);"}, "dataset2_info": {"data_index": 403, "step_index": 28, "label": 1, "code": "    quantum_info=DestroyQuantumInfo(quantum_info);"}}
{"step": "    quantum_info=DestroyQuantumInfo(quantum_info);", "dataset1_info": {"data_index": 3415, "step_index": 55, "label": 0, "code": "    quantum_info=DestroyQuantumInfo(quantum_info);"}, "dataset2_info": {"data_index": 403, "step_index": 28, "label": 1, "code": "    quantum_info=DestroyQuantumInfo(quantum_info);"}}
{"step": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file", "dataset1_info": {"data_index": 3888, "step_index": 7, "label": 0, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}, "dataset2_info": {"data_index": 398, "step_index": 7, "label": 1, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}}
{"step": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file", "dataset1_info": {"data_index": 3888, "step_index": 7, "label": 0, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}, "dataset2_info": {"data_index": 398, "step_index": 7, "label": 1, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}}
{"step": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file", "dataset1_info": {"data_index": 3889, "step_index": 7, "label": 0, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}, "dataset2_info": {"data_index": 398, "step_index": 7, "label": 1, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}}
{"step": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file", "dataset1_info": {"data_index": 3889, "step_index": 7, "label": 0, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}, "dataset2_info": {"data_index": 398, "step_index": 7, "label": 1, "code": "    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file"}}
{"step": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);", "dataset1_info": {"data_index": 3922, "step_index": 10, "label": 0, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}, "dataset2_info": {"data_index": 512, "step_index": 10, "label": 1, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}}
{"step": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);", "dataset1_info": {"data_index": 3922, "step_index": 10, "label": 0, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}, "dataset2_info": {"data_index": 512, "step_index": 10, "label": 1, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}}
{"step": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);", "dataset1_info": {"data_index": 3923, "step_index": 10, "label": 0, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}, "dataset2_info": {"data_index": 512, "step_index": 10, "label": 1, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}}
{"step": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);", "dataset1_info": {"data_index": 3923, "step_index": 10, "label": 0, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}, "dataset2_info": {"data_index": 512, "step_index": 10, "label": 1, "code": "    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);"}}
{"step": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4054, "step_index": 3, "label": 0, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 1, "label": 1, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}}
{"step": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4054, "step_index": 3, "label": 0, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 1, "label": 1, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}}
{"step": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4054, "step_index": 15, "label": 0, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 9, "label": 1, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}}
{"step": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4054, "step_index": 15, "label": 0, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 9, "label": 1, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}}
{"step": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4055, "step_index": 3, "label": 0, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 1, "label": 1, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}}
{"step": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4055, "step_index": 3, "label": 0, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 1, "label": 1, "code": "\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}"}}
{"step": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4055, "step_index": 15, "label": 0, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 9, "label": 1, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}}
{"step": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}", "dataset1_info": {"data_index": 4055, "step_index": 15, "label": 0, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}, "dataset2_info": {"data_index": 637, "step_index": 9, "label": 1, "code": "\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}"}}
{"step": "  MemoryInfo\n    *volatile pixel_info;", "dataset1_info": {"data_index": 4235, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *volatile pixel_info;"}, "dataset2_info": {"data_index": 646, "step_index": 19, "label": 1, "code": "  MemoryInfo\n    *volatile pixel_info;"}}
{"step": "  MemoryInfo\n    *volatile pixel_info;", "dataset1_info": {"data_index": 4235, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *volatile pixel_info;"}, "dataset2_info": {"data_index": 646, "step_index": 19, "label": 1, "code": "  MemoryInfo\n    *volatile pixel_info;"}}
{"step": "  PNGErrorInfo\n    error_info;", "dataset1_info": {"data_index": 4235, "step_index": 14, "label": 0, "code": "  PNGErrorInfo\n    error_info;"}, "dataset2_info": {"data_index": 646, "step_index": 21, "label": 1, "code": "  PNGErrorInfo\n    error_info;"}}
{"step": "  PNGErrorInfo\n    error_info;", "dataset1_info": {"data_index": 4235, "step_index": 14, "label": 0, "code": "  PNGErrorInfo\n    error_info;"}, "dataset2_info": {"data_index": 646, "step_index": 21, "label": 1, "code": "  PNGErrorInfo\n    error_info;"}}
{"step": "  png_struct\n    *ping;", "dataset1_info": {"data_index": 4235, "step_index": 18, "label": 0, "code": "  png_struct\n    *ping;"}, "dataset2_info": {"data_index": 646, "step_index": 11, "label": 1, "code": "  png_struct\n    *ping;"}}
{"step": "  png_struct\n    *ping;", "dataset1_info": {"data_index": 4235, "step_index": 18, "label": 0, "code": "  png_struct\n    *ping;"}, "dataset2_info": {"data_index": 646, "step_index": 11, "label": 1, "code": "  png_struct\n    *ping;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 472, "step_index": 5, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 472, "step_index": 5, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 646, "step_index": 20, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 646, "step_index": 20, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 688, "step_index": 2, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  QuantumInfo\n    *quantum_info;", "dataset1_info": {"data_index": 4235, "step_index": 22, "label": 0, "code": "  QuantumInfo\n    *quantum_info;"}, "dataset2_info": {"data_index": 688, "step_index": 2, "label": 1, "code": "  QuantumInfo\n    *quantum_info;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 4235, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  unsigned char\n    *ping_pixels;", "dataset1_info": {"data_index": 4235, "step_index": 31, "label": 0, "code": "  unsigned char\n    *ping_pixels;"}, "dataset2_info": {"data_index": 646, "step_index": 23, "label": 1, "code": "  unsigned char\n    *ping_pixels;"}}
{"step": "  unsigned char\n    *ping_pixels;", "dataset1_info": {"data_index": 4235, "step_index": 31, "label": 0, "code": "  unsigned char\n    *ping_pixels;"}, "dataset2_info": {"data_index": 646, "step_index": 23, "label": 1, "code": "  unsigned char\n    *ping_pixels;"}}
{"step": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);", "dataset1_info": {"data_index": 4235, "step_index": 34, "label": 0, "code": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);"}, "dataset2_info": {"data_index": 646, "step_index": 35, "label": 1, "code": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);"}}
{"step": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);", "dataset1_info": {"data_index": 4235, "step_index": 34, "label": 0, "code": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);"}, "dataset2_info": {"data_index": 646, "step_index": 35, "label": 1, "code": "  *libpng_vers='\\0';\n  (void) ConcatenateMagickString(libpng_vers,\n         PNG_LIBPNG_VER_STRING,32);\n  *libpng_runv='\\0';\n  (void) ConcatenateMagickString(libpng_runv,\n         png_get_libpng_ver(NULL),32);"}}
{"step": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);", "dataset1_info": {"data_index": 4235, "step_index": 35, "label": 0, "code": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);"}, "dataset2_info": {"data_index": 646, "step_index": 36, "label": 1, "code": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);"}}
{"step": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);", "dataset1_info": {"data_index": 4235, "step_index": 35, "label": 0, "code": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);"}, "dataset2_info": {"data_index": 646, "step_index": 36, "label": 1, "code": "  *zlib_vers='\\0';\n  (void) ConcatenateMagickString(zlib_vers,\n         ZLIB_VERSION,32);\n  *zlib_runv='\\0';\n  (void) ConcatenateMagickString(zlib_runv,\n         zlib_version,32);"}}
{"step": "  ping_info=png_create_info_struct(ping);", "dataset1_info": {"data_index": 4235, "step_index": 48, "label": 0, "code": "  ping_info=png_create_info_struct(ping);"}, "dataset2_info": {"data_index": 646, "step_index": 232, "label": 1, "code": "  ping_info=png_create_info_struct(ping);"}}
{"step": "  ping_info=png_create_info_struct(ping);", "dataset1_info": {"data_index": 4235, "step_index": 48, "label": 0, "code": "  ping_info=png_create_info_struct(ping);"}, "dataset2_info": {"data_index": 646, "step_index": 232, "label": 1, "code": "  ping_info=png_create_info_struct(ping);"}}
{"step": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */", "dataset1_info": {"data_index": 4235, "step_index": 58, "label": 0, "code": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */"}, "dataset2_info": {"data_index": 646, "step_index": 239, "label": 1, "code": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */"}}
{"step": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */", "dataset1_info": {"data_index": 4235, "step_index": 58, "label": 0, "code": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */"}, "dataset2_info": {"data_index": 646, "step_index": 239, "label": 1, "code": "  /* {  For navigation to end of SETJMP-protected block.  Within this\n   *    block, use png_error() instead of Throwing an Exception, to ensure\n   *    that libpng is able to clean up, and that the semaphore is unlocked.\n   */"}}
{"step": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 59, "label": 0, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 240, "label": 1, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif"}}
{"step": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 59, "label": 0, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 240, "label": 1, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  LockSemaphoreInfo(ping_semaphore);\n#endif"}}
{"step": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 60, "label": 0, "code": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 241, "label": 1, "code": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif"}}
{"step": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 60, "label": 0, "code": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 241, "label": 1, "code": "#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n  /* Allow benign errors */\n  png_set_benign_errors(ping, 1);\n#endif"}}
{"step": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */", "dataset1_info": {"data_index": 4235, "step_index": 61, "label": 0, "code": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */"}, "dataset2_info": {"data_index": 646, "step_index": 242, "label": 1, "code": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */"}}
{"step": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */", "dataset1_info": {"data_index": 4235, "step_index": 61, "label": 0, "code": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */"}, "dataset2_info": {"data_index": 646, "step_index": 242, "label": 1, "code": "#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n  /* Reject images with too many rows or columns */\n  png_set_user_limits(ping,\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(WidthResource)),\n    (png_uint_32) MagickMin(0x7fffffffL,\n        GetMagickResourceLimit(HeightResource)));\n#endif /* PNG_SET_USER_LIMITS_SUPPORTED */"}}
{"step": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;", "dataset1_info": {"data_index": 4235, "step_index": 113, "label": 0, "code": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;"}, "dataset2_info": {"data_index": 646, "step_index": 50, "label": 1, "code": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;"}}
{"step": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;", "dataset1_info": {"data_index": 4235, "step_index": 113, "label": 0, "code": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;"}, "dataset2_info": {"data_index": 646, "step_index": 50, "label": 1, "code": "\n                 png_uint_32\n                   length,\n                   profile_crc=0;"}}
{"step": "                 unsigned char\n                   *data;", "dataset1_info": {"data_index": 4235, "step_index": 114, "label": 0, "code": "                 unsigned char\n                   *data;"}, "dataset2_info": {"data_index": 646, "step_index": 51, "label": 1, "code": "                 unsigned char\n                   *data;"}}
{"step": "                 unsigned char\n                   *data;", "dataset1_info": {"data_index": 4235, "step_index": 114, "label": 0, "code": "                 unsigned char\n                   *data;"}, "dataset2_info": {"data_index": 646, "step_index": 51, "label": 1, "code": "                 unsigned char\n                   *data;"}}
{"step": "                 length=(png_uint_32) GetStringInfoLength(profile);", "dataset1_info": {"data_index": 4235, "step_index": 115, "label": 0, "code": "                 length=(png_uint_32) GetStringInfoLength(profile);"}, "dataset2_info": {"data_index": 646, "step_index": 52, "label": 1, "code": "                 length=(png_uint_32) GetStringInfoLength(profile);"}}
{"step": "                 length=(png_uint_32) GetStringInfoLength(profile);", "dataset1_info": {"data_index": 4235, "step_index": 115, "label": 0, "code": "                 length=(png_uint_32) GetStringInfoLength(profile);"}, "dataset2_info": {"data_index": 646, "step_index": 52, "label": 1, "code": "                 length=(png_uint_32) GetStringInfoLength(profile);"}}
{"step": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);", "dataset1_info": {"data_index": 4235, "step_index": 116, "label": 0, "code": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);"}, "dataset2_info": {"data_index": 646, "step_index": 53, "label": 1, "code": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);"}}
{"step": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);", "dataset1_info": {"data_index": 4235, "step_index": 116, "label": 0, "code": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);"}, "dataset2_info": {"data_index": 646, "step_index": 53, "label": 1, "code": "                 for (icheck=0; sRGB_info[icheck].len > 0; icheck++)\n                 {\n                   if (length == sRGB_info[icheck].len)\n                   {\n                     if (got_crc == 0)\n                     {\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"    Got a %lu-byte ICC profile (potentially sRGB)\",\n                         (unsigned long) length);"}}
{"step": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);", "dataset1_info": {"data_index": 4235, "step_index": 117, "label": 0, "code": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);"}, "dataset2_info": {"data_index": 646, "step_index": 54, "label": 1, "code": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);"}}
{"step": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);", "dataset1_info": {"data_index": 4235, "step_index": 117, "label": 0, "code": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);"}, "dataset2_info": {"data_index": 646, "step_index": 54, "label": 1, "code": "                       data=GetStringInfoDatum(profile);\n                       profile_crc=crc32(0,data,length);"}}
{"step": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }", "dataset1_info": {"data_index": 4235, "step_index": 118, "label": 0, "code": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }"}, "dataset2_info": {"data_index": 646, "step_index": 55, "label": 1, "code": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }"}}
{"step": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }", "dataset1_info": {"data_index": 4235, "step_index": 118, "label": 0, "code": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }"}, "dataset2_info": {"data_index": 646, "step_index": 55, "label": 1, "code": "                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                           \"      with crc=%8x\",(unsigned int) profile_crc);\n                       got_crc++;\n                     }"}}
{"step": "  pixel_info=RelinquishVirtualMemory(pixel_info);", "dataset1_info": {"data_index": 4235, "step_index": 370, "label": 0, "code": "  pixel_info=RelinquishVirtualMemory(pixel_info);"}, "dataset2_info": {"data_index": 646, "step_index": 597, "label": 1, "code": "  pixel_info=RelinquishVirtualMemory(pixel_info);"}}
{"step": "  pixel_info=RelinquishVirtualMemory(pixel_info);", "dataset1_info": {"data_index": 4235, "step_index": 370, "label": 0, "code": "  pixel_info=RelinquishVirtualMemory(pixel_info);"}, "dataset2_info": {"data_index": 646, "step_index": 597, "label": 1, "code": "  pixel_info=RelinquishVirtualMemory(pixel_info);"}}
{"step": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 372, "label": 0, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 603, "label": 1, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif"}}
{"step": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif", "dataset1_info": {"data_index": 4235, "step_index": 372, "label": 0, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif"}, "dataset2_info": {"data_index": 646, "step_index": 603, "label": 1, "code": "#ifdef IMPNG_SETJMP_NOT_THREAD_SAFE\n  UnlockSemaphoreInfo(ping_semaphore);\n#endif"}}
{"step": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {", "dataset1_info": {"data_index": 4496, "step_index": 6, "label": 1, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}, "dataset2_info": {"data_index": 415, "step_index": 6, "label": 0, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}}
{"step": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {", "dataset1_info": {"data_index": 4496, "step_index": 6, "label": 1, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}, "dataset2_info": {"data_index": 415, "step_index": 6, "label": 0, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}}
{"step": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {", "dataset1_info": {"data_index": 4497, "step_index": 6, "label": 1, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}, "dataset2_info": {"data_index": 415, "step_index": 6, "label": 0, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}}
{"step": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {", "dataset1_info": {"data_index": 4497, "step_index": 6, "label": 1, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}, "dataset2_info": {"data_index": 415, "step_index": 6, "label": 0, "code": "                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"}}
{"step": "  ssize_t\n    count;", "dataset1_info": {"data_index": 5013, "step_index": 12, "label": 0, "code": "  ssize_t\n    count;"}, "dataset2_info": {"data_index": 412, "step_index": 7, "label": 1, "code": "  ssize_t\n    count;"}}
{"step": "  ssize_t\n    count;", "dataset1_info": {"data_index": 5013, "step_index": 12, "label": 0, "code": "  ssize_t\n    count;"}, "dataset2_info": {"data_index": 412, "step_index": 7, "label": 1, "code": "  ssize_t\n    count;"}}
{"step": "  ssize_t\n    count;", "dataset1_info": {"data_index": 5013, "step_index": 12, "label": 0, "code": "  ssize_t\n    count;"}, "dataset2_info": {"data_index": 463, "step_index": 3, "label": 1, "code": "  ssize_t\n    count;"}}
{"step": "  ssize_t\n    count;", "dataset1_info": {"data_index": 5013, "step_index": 12, "label": 0, "code": "  ssize_t\n    count;"}, "dataset2_info": {"data_index": 463, "step_index": 3, "label": 1, "code": "  ssize_t\n    count;"}}
{"step": "   *unsupported = false;", "dataset1_info": {"data_index": 5055, "step_index": 4, "label": 0, "code": "   *unsupported = false;"}, "dataset2_info": {"data_index": 422, "step_index": 2, "label": 1, "code": "   *unsupported = false;"}}
{"step": "   *unsupported = false;", "dataset1_info": {"data_index": 5055, "step_index": 4, "label": 0, "code": "   *unsupported = false;"}, "dataset2_info": {"data_index": 422, "step_index": 2, "label": 1, "code": "   *unsupported = false;"}}
{"step": "   data = iter->raw;\n   len = iter->len;", "dataset1_info": {"data_index": 5055, "step_index": 8, "label": 0, "code": "   data = iter->raw;\n   len = iter->len;"}, "dataset2_info": {"data_index": 422, "step_index": 4, "label": 1, "code": "   data = iter->raw;\n   len = iter->len;"}}
{"step": "   data = iter->raw;\n   len = iter->len;", "dataset1_info": {"data_index": 5055, "step_index": 8, "label": 0, "code": "   data = iter->raw;\n   len = iter->len;"}, "dataset2_info": {"data_index": 422, "step_index": 4, "label": 1, "code": "   data = iter->raw;\n   len = iter->len;"}}
{"step": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;", "dataset1_info": {"data_index": 5055, "step_index": 9, "label": 0, "code": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 5, "label": 1, "code": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;"}}
{"step": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;", "dataset1_info": {"data_index": 5055, "step_index": 9, "label": 0, "code": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 5, "label": 1, "code": "   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;"}}
{"step": "   goto mark_invalid;", "dataset1_info": {"data_index": 5055, "step_index": 12, "label": 0, "code": "   goto mark_invalid;"}, "dataset2_info": {"data_index": 422, "step_index": 7, "label": 1, "code": "   goto mark_invalid;"}}
{"step": "   goto mark_invalid;", "dataset1_info": {"data_index": 5055, "step_index": 12, "label": 0, "code": "   goto mark_invalid;"}, "dataset2_info": {"data_index": 422, "step_index": 7, "label": 1, "code": "   goto mark_invalid;"}}
{"step": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);", "dataset1_info": {"data_index": 5055, "step_index": 14, "label": 0, "code": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);"}, "dataset2_info": {"data_index": 422, "step_index": 9, "label": 1, "code": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);"}}
{"step": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);", "dataset1_info": {"data_index": 5055, "step_index": 14, "label": 0, "code": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);"}, "dataset2_info": {"data_index": 422, "step_index": 9, "label": 1, "code": "   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);"}}
{"step": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 15, "label": 0, "code": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 10, "label": 1, "code": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;"}}
{"step": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 15, "label": 0, "code": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 10, "label": 1, "code": "   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;"}}
{"step": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 16, "label": 0, "code": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 11, "label": 1, "code": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 16, "label": 0, "code": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 11, "label": 1, "code": "      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 17, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 12, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 17, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 40, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 17, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 12, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 17, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 40, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 18, "label": 0, "code": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 13, "label": 1, "code": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 18, "label": 0, "code": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 13, "label": 1, "code": "      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->next_off = o + 4 + l;", "dataset1_info": {"data_index": 5055, "step_index": 19, "label": 0, "code": "      iter->next_off = o + 4 + l;"}, "dataset2_info": {"data_index": 422, "step_index": 14, "label": 1, "code": "      iter->next_off = o + 4 + l;"}}
{"step": "      iter->next_off = o + 4 + l;", "dataset1_info": {"data_index": 5055, "step_index": 19, "label": 0, "code": "      iter->next_off = o + 4 + l;"}, "dataset2_info": {"data_index": 422, "step_index": 14, "label": 1, "code": "      iter->next_off = o + 4 + l;"}}
{"step": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 20, "label": 0, "code": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 15, "label": 1, "code": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 20, "label": 0, "code": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 15, "label": 1, "code": "      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 21, "label": 0, "code": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 16, "label": 1, "code": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;"}}
{"step": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 21, "label": 0, "code": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 16, "label": 1, "code": "      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 22, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;", "dataset1_info": {"data_index": 5055, "step_index": 23, "label": 0, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;"}, "dataset2_info": {"data_index": 422, "step_index": 18, "label": 1, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;"}}
{"step": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;", "dataset1_info": {"data_index": 5055, "step_index": 23, "label": 0, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;"}, "dataset2_info": {"data_index": 422, "step_index": 18, "label": 1, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 5;"}}
{"step": "      subtype = *(iter->raw + iter->d2);", "dataset1_info": {"data_index": 5055, "step_index": 25, "label": 0, "code": "      subtype = *(iter->raw + iter->d2);"}, "dataset2_info": {"data_index": 422, "step_index": 22, "label": 1, "code": "      subtype = *(iter->raw + iter->d2);"}}
{"step": "      subtype = *(iter->raw + iter->d2);", "dataset1_info": {"data_index": 5055, "step_index": 25, "label": 0, "code": "      subtype = *(iter->raw + iter->d2);"}, "dataset2_info": {"data_index": 422, "step_index": 22, "label": 1, "code": "      subtype = *(iter->raw + iter->d2);"}}
{"step": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;", "dataset1_info": {"data_index": 5055, "step_index": 26, "label": 0, "code": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;"}, "dataset2_info": {"data_index": 422, "step_index": 23, "label": 1, "code": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;"}}
{"step": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;", "dataset1_info": {"data_index": 5055, "step_index": 26, "label": 0, "code": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;"}, "dataset2_info": {"data_index": 422, "step_index": 23, "label": 1, "code": "      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;"}}
{"step": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }", "dataset1_info": {"data_index": 5055, "step_index": 27, "label": 0, "code": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }"}, "dataset2_info": {"data_index": 422, "step_index": 24, "label": 1, "code": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }"}}
{"step": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }", "dataset1_info": {"data_index": 5055, "step_index": 27, "label": 0, "code": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }"}, "dataset2_info": {"data_index": 422, "step_index": 24, "label": 1, "code": "         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }"}}
{"step": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 28, "label": 0, "code": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 25, "label": 1, "code": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }"}}
{"step": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 28, "label": 0, "code": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 25, "label": 1, "code": "         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }"}}
{"step": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 29, "label": 0, "code": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 26, "label": 1, "code": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;"}}
{"step": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 29, "label": 0, "code": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 26, "label": 1, "code": "      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 30, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 31, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 28, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 31, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 46, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 31, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 28, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 31, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 46, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 32, "label": 0, "code": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 29, "label": 1, "code": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 32, "label": 0, "code": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 29, "label": 1, "code": "      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;", "dataset1_info": {"data_index": 5055, "step_index": 33, "label": 0, "code": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;"}, "dataset2_info": {"data_index": 422, "step_index": 30, "label": 1, "code": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;"}}
{"step": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;", "dataset1_info": {"data_index": 5055, "step_index": 33, "label": 0, "code": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;"}, "dataset2_info": {"data_index": 422, "step_index": 30, "label": 1, "code": "      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;"}}
{"step": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 34, "label": 0, "code": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 31, "label": 1, "code": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 34, "label": 0, "code": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 31, "label": 1, "code": "      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 35, "label": 0, "code": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 32, "label": 1, "code": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 35, "label": 0, "code": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 32, "label": 1, "code": "      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;", "dataset1_info": {"data_index": 5055, "step_index": 36, "label": 0, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;"}, "dataset2_info": {"data_index": 422, "step_index": 33, "label": 1, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;"}}
{"step": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;", "dataset1_info": {"data_index": 5055, "step_index": 36, "label": 0, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;"}, "dataset2_info": {"data_index": 422, "step_index": 33, "label": 1, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;"}}
{"step": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 37, "label": 0, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 34, "label": 1, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }"}}
{"step": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 37, "label": 0, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 34, "label": 1, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }"}}
{"step": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 38, "label": 0, "code": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 35, "label": 1, "code": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}}
{"step": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 38, "label": 0, "code": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 35, "label": 1, "code": "      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}}
{"step": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 39, "label": 0, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 36, "label": 1, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }"}}
{"step": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }", "dataset1_info": {"data_index": 5055, "step_index": 39, "label": 0, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 36, "label": 1, "code": "      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }"}}
{"step": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 40, "label": 0, "code": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 37, "label": 1, "code": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}}
{"step": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 40, "label": 0, "code": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 37, "label": 1, "code": "      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 41, "label": 0, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 38, "label": 1, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;"}}
{"step": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;", "dataset1_info": {"data_index": 5055, "step_index": 41, "label": 0, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;"}, "dataset2_info": {"data_index": 422, "step_index": 38, "label": 1, "code": "      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 17, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 27, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 42, "label": 0, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 39, "label": 1, "code": "      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 43, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 12, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 43, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 40, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 43, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 12, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 43, "label": 0, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 40, "label": 1, "code": "      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 44, "label": 0, "code": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 41, "label": 1, "code": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 44, "label": 0, "code": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 41, "label": 1, "code": "      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 45, "label": 0, "code": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 42, "label": 1, "code": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }"}}
{"step": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 45, "label": 0, "code": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 42, "label": 1, "code": "      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;", "dataset1_info": {"data_index": 5055, "step_index": 46, "label": 0, "code": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;"}, "dataset2_info": {"data_index": 422, "step_index": 43, "label": 1, "code": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;"}}
{"step": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;", "dataset1_info": {"data_index": 5055, "step_index": 46, "label": 0, "code": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;"}, "dataset2_info": {"data_index": 422, "step_index": 43, "label": 1, "code": "      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;"}}
{"step": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 47, "label": 0, "code": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 44, "label": 1, "code": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 47, "label": 0, "code": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 44, "label": 1, "code": "      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;", "dataset1_info": {"data_index": 5055, "step_index": 48, "label": 0, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;"}, "dataset2_info": {"data_index": 422, "step_index": 45, "label": 1, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;"}}
{"step": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;", "dataset1_info": {"data_index": 5055, "step_index": 48, "label": 0, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;"}, "dataset2_info": {"data_index": 422, "step_index": 45, "label": 1, "code": "      iter->d2 = o + 4;\n      iter->d3 = o + 8;"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 49, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 28, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 49, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 46, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 49, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 28, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 49, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 46, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 50, "label": 0, "code": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 47, "label": 1, "code": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 50, "label": 0, "code": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 47, "label": 1, "code": "      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->next_off = o + l;", "dataset1_info": {"data_index": 5055, "step_index": 51, "label": 0, "code": "      iter->next_off = o + l;"}, "dataset2_info": {"data_index": 422, "step_index": 48, "label": 1, "code": "      iter->next_off = o + l;"}}
{"step": "      iter->next_off = o + l;", "dataset1_info": {"data_index": 5055, "step_index": 51, "label": 0, "code": "      iter->next_off = o + l;"}, "dataset2_info": {"data_index": 422, "step_index": 48, "label": 1, "code": "      iter->next_off = o + l;"}}
{"step": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 52, "label": 0, "code": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 49, "label": 1, "code": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 52, "label": 0, "code": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 49, "label": 1, "code": "      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 53, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 50, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);", "dataset1_info": {"data_index": 5055, "step_index": 53, "label": 0, "code": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}, "dataset2_info": {"data_index": 422, "step_index": 50, "label": 1, "code": "      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);"}}
{"step": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 54, "label": 0, "code": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 51, "label": 1, "code": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 54, "label": 0, "code": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 51, "label": 1, "code": "      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 55, "label": 0, "code": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 52, "label": 1, "code": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }"}}
{"step": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }", "dataset1_info": {"data_index": 5055, "step_index": 55, "label": 0, "code": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }"}, "dataset2_info": {"data_index": 422, "step_index": 52, "label": 1, "code": "      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }"}}
{"step": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);", "dataset1_info": {"data_index": 5055, "step_index": 56, "label": 0, "code": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);"}, "dataset2_info": {"data_index": 422, "step_index": 53, "label": 1, "code": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);"}}
{"step": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);", "dataset1_info": {"data_index": 5055, "step_index": 56, "label": 0, "code": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);"}, "dataset2_info": {"data_index": 422, "step_index": 53, "label": 1, "code": "      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);"}}
{"step": "   iter->err_off = 0;", "dataset1_info": {"data_index": 5055, "step_index": 61, "label": 0, "code": "   iter->err_off = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 56, "label": 1, "code": "   iter->err_off = 0;"}}
{"step": "   iter->err_off = 0;", "dataset1_info": {"data_index": 5055, "step_index": 61, "label": 0, "code": "   iter->err_off = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 56, "label": 1, "code": "   iter->err_off = 0;"}}
{"step": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;", "dataset1_info": {"data_index": 5055, "step_index": 63, "label": 0, "code": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 58, "label": 1, "code": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;"}}
{"step": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;", "dataset1_info": {"data_index": 5055, "step_index": 63, "label": 0, "code": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;"}, "dataset2_info": {"data_index": 422, "step_index": 58, "label": 1, "code": "mark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 195, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 195, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 243, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 243, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 272, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 272, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 344, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 344, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 346, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 346, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 356, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 356, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 371, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "        return result;", "dataset1_info": {"data_index": 5087, "step_index": 8, "label": 0, "code": "        return result;"}, "dataset2_info": {"data_index": 371, "step_index": 2, "label": 1, "code": "        return result;"}}
{"step": "            continue;", "dataset1_info": {"data_index": 5297, "step_index": 46, "label": 0, "code": "            continue;"}, "dataset2_info": {"data_index": 629, "step_index": 3, "label": 1, "code": "            continue;"}}
{"step": "            continue;", "dataset1_info": {"data_index": 5297, "step_index": 46, "label": 0, "code": "            continue;"}, "dataset2_info": {"data_index": 629, "step_index": 3, "label": 1, "code": "            continue;"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5310, "step_index": 40, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5310, "step_index": 40, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5310, "step_index": 45, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5310, "step_index": 45, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5310, "step_index": 40, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5310, "step_index": 40, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5310, "step_index": 45, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5310, "step_index": 45, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5311, "step_index": 40, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5311, "step_index": 40, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5311, "step_index": 45, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len-- > 0)", "dataset1_info": {"data_index": 5311, "step_index": 45, "label": 0, "code": "                    while (len-- > 0)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 1, "code": "                    while (len-- > 0)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5311, "step_index": 40, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5311, "step_index": 40, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5311, "step_index": 45, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 21, "label": 0, "code": "                    while (len--)"}}
{"step": "                    while (len--)", "dataset1_info": {"data_index": 5311, "step_index": 45, "label": 1, "code": "                    while (len--)"}, "dataset2_info": {"data_index": 397, "step_index": 24, "label": 0, "code": "                    while (len--)"}}
{"step": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;", "dataset1_info": {"data_index": 5331, "step_index": 3, "label": 0, "code": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;"}, "dataset2_info": {"data_index": 506, "step_index": 3, "label": 1, "code": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;"}}
{"step": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;", "dataset1_info": {"data_index": 5331, "step_index": 3, "label": 0, "code": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;"}, "dataset2_info": {"data_index": 506, "step_index": 3, "label": 1, "code": "\tif (requeue_pi) {\n\t\t/*\n\t\t * Requeue PI only works on two distinct uaddrs. This\n\t\t * check is only valid for private futexes. See below.\n\t\t */\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;"}}
{"step": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 4, "label": 0, "code": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 4, "label": 1, "code": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}"}}
{"step": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 4, "label": 0, "code": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 4, "label": 1, "code": "\t\t/*\n\t\t * requeue_pi requires a pi_state, try to allocate it now\n\t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}"}}
{"step": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;", "dataset1_info": {"data_index": 5331, "step_index": 5, "label": 0, "code": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;"}, "dataset2_info": {"data_index": 506, "step_index": 5, "label": 1, "code": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;"}}
{"step": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;", "dataset1_info": {"data_index": 5331, "step_index": 5, "label": 0, "code": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;"}, "dataset2_info": {"data_index": 506, "step_index": 5, "label": 1, "code": "retry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;"}}
{"step": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 6, "label": 0, "code": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 6, "label": 1, "code": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}"}}
{"step": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 6, "label": 0, "code": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 6, "label": 1, "code": "\t/*\n\t * The check above which compares uaddrs is not sufficient for\n\t * shared futexes. We need to compare the keys:\n\t */\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_keys;\n\t}"}}
{"step": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);", "dataset1_info": {"data_index": 5331, "step_index": 7, "label": 0, "code": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);"}, "dataset2_info": {"data_index": 506, "step_index": 7, "label": 1, "code": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);"}}
{"step": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);", "dataset1_info": {"data_index": 5331, "step_index": 7, "label": 0, "code": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);"}, "dataset2_info": {"data_index": 506, "step_index": 7, "label": 1, "code": "\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);"}}
{"step": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);", "dataset1_info": {"data_index": 5331, "step_index": 8, "label": 0, "code": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 8, "label": 1, "code": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);"}}
{"step": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);", "dataset1_info": {"data_index": 5331, "step_index": 8, "label": 0, "code": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 8, "label": 1, "code": "retry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);"}}
{"step": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;", "dataset1_info": {"data_index": 5331, "step_index": 9, "label": 0, "code": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;"}, "dataset2_info": {"data_index": 506, "step_index": 9, "label": 1, "code": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;"}}
{"step": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;", "dataset1_info": {"data_index": 5331, "step_index": 9, "label": 0, "code": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;"}, "dataset2_info": {"data_index": 506, "step_index": 9, "label": 1, "code": "\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;"}}
{"step": "\t\tret = get_futex_value_locked(&curval, uaddr1);", "dataset1_info": {"data_index": 5331, "step_index": 10, "label": 0, "code": "\t\tret = get_futex_value_locked(&curval, uaddr1);"}, "dataset2_info": {"data_index": 506, "step_index": 10, "label": 1, "code": "\t\tret = get_futex_value_locked(&curval, uaddr1);"}}
{"step": "\t\tret = get_futex_value_locked(&curval, uaddr1);", "dataset1_info": {"data_index": 5331, "step_index": 10, "label": 0, "code": "\t\tret = get_futex_value_locked(&curval, uaddr1);"}, "dataset2_info": {"data_index": 506, "step_index": 10, "label": 1, "code": "\t\tret = get_futex_value_locked(&curval, uaddr1);"}}
{"step": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);", "dataset1_info": {"data_index": 5331, "step_index": 11, "label": 0, "code": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 11, "label": 1, "code": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);"}}
{"step": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);", "dataset1_info": {"data_index": 5331, "step_index": 11, "label": 0, "code": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 11, "label": 1, "code": "\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);"}}
{"step": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;", "dataset1_info": {"data_index": 5331, "step_index": 12, "label": 0, "code": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;"}, "dataset2_info": {"data_index": 506, "step_index": 12, "label": 1, "code": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;"}}
{"step": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;", "dataset1_info": {"data_index": 5331, "step_index": 12, "label": 0, "code": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;"}, "dataset2_info": {"data_index": 506, "step_index": 12, "label": 1, "code": "\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;"}}
{"step": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;", "dataset1_info": {"data_index": 5331, "step_index": 13, "label": 0, "code": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;"}, "dataset2_info": {"data_index": 506, "step_index": 13, "label": 1, "code": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;"}}
{"step": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;", "dataset1_info": {"data_index": 5331, "step_index": 13, "label": 0, "code": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;"}, "dataset2_info": {"data_index": 506, "step_index": 13, "label": 1, "code": "\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;"}}
{"step": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 14, "label": 0, "code": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 14, "label": 1, "code": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}"}}
{"step": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 14, "label": 0, "code": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 14, "label": 1, "code": "\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}"}}
{"step": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);", "dataset1_info": {"data_index": 5331, "step_index": 15, "label": 0, "code": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);"}, "dataset2_info": {"data_index": 506, "step_index": 15, "label": 1, "code": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);"}}
{"step": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);", "dataset1_info": {"data_index": 5331, "step_index": 15, "label": 0, "code": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);"}, "dataset2_info": {"data_index": 506, "step_index": 15, "label": 1, "code": "\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);"}}
{"step": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 16, "label": 0, "code": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 16, "label": 1, "code": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}"}}
{"step": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 16, "label": 0, "code": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 16, "label": 1, "code": "\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t * If the lock was not taken, we have pi_state and an initial\n\t\t * refcount on it. In case of an error we have nothing.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user space value\n\t\t\t * of uaddr2 should be vpid. It cannot be changed by\n\t\t\t * the top waiter as it is blocked on hb2 lock if it\n\t\t\t * tries to do so. If something fiddled with it behind\n\t\t\t * our back the pi state lookup might unearth it. So\n\t\t\t * we rather use the known value than rereading and\n\t\t\t * handing potential crap to lookup_pi_state.\n\t\t\t *\n\t\t\t * If that call succeeds then we have pi_state and an\n\t\t\t * initial refcount on it.\n\t\t\t */\n\t\t\tret = lookup_pi_state(uaddr2, ret, hb2, &key2, &pi_state);\n\t\t}"}}
{"step": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;", "dataset1_info": {"data_index": 5331, "step_index": 17, "label": 0, "code": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;"}, "dataset2_info": {"data_index": 506, "step_index": 17, "label": 1, "code": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;"}}
{"step": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;", "dataset1_info": {"data_index": 5331, "step_index": 17, "label": 0, "code": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;"}, "dataset2_info": {"data_index": 506, "step_index": 17, "label": 1, "code": "\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t/* We hold a reference on the pi state. */\n\t\t\tbreak;"}}
{"step": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;", "dataset1_info": {"data_index": 5331, "step_index": 21, "label": 0, "code": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;"}, "dataset2_info": {"data_index": 506, "step_index": 19, "label": 1, "code": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;"}}
{"step": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;", "dataset1_info": {"data_index": 5331, "step_index": 21, "label": 0, "code": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;"}, "dataset2_info": {"data_index": 506, "step_index": 19, "label": 1, "code": "\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;"}}
{"step": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;", "dataset1_info": {"data_index": 5331, "step_index": 22, "label": 0, "code": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;"}, "dataset2_info": {"data_index": 506, "step_index": 20, "label": 1, "code": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;"}}
{"step": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;", "dataset1_info": {"data_index": 5331, "step_index": 22, "label": 0, "code": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;"}, "dataset2_info": {"data_index": 506, "step_index": 20, "label": 1, "code": "\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;"}}
{"step": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 26, "label": 0, "code": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 22, "label": 1, "code": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}"}}
{"step": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 26, "label": 0, "code": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 22, "label": 1, "code": "\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\tmark_wake_futex(&wake_q, this);\n\t\t\tcontinue;\n\t\t}"}}
{"step": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 27, "label": 0, "code": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 23, "label": 1, "code": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}"}}
{"step": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}", "dataset1_info": {"data_index": 5331, "step_index": 27, "label": 0, "code": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}"}, "dataset2_info": {"data_index": 506, "step_index": 23, "label": 1, "code": "\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}"}}
{"step": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 28, "label": 0, "code": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 24, "label": 1, "code": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}"}}
{"step": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}", "dataset1_info": {"data_index": 5331, "step_index": 28, "label": 0, "code": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}"}, "dataset2_info": {"data_index": 506, "step_index": 24, "label": 1, "code": "\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/*\n\t\t\t * Prepare the waiter to take the rt_mutex. Take a\n\t\t\t * refcount on the pi_state and store the pointer in\n\t\t\t * the futex_q object of the waiter.\n\t\t\t */\n\t\t\tget_pi_state(pi_state);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * We got the lock. We do neither drop the\n\t\t\t\t * refcount on pi_state nor clear\n\t\t\t\t * this->pi_state because the waiter needs the\n\t\t\t\t * pi_state for cleaning up the user space\n\t\t\t\t * value. It will drop the refcount after\n\t\t\t\t * doing so.\n\t\t\t\t */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/*\n\t\t\t\t * rt_mutex_start_proxy_lock() detected a\n\t\t\t\t * potential deadlock when we tried to queue\n\t\t\t\t * that waiter. Drop the pi_state reference\n\t\t\t\t * which we took above and remove the pointer\n\t\t\t\t * to the state from the waiters futex_q\n\t\t\t\t * object.\n\t\t\t\t */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tput_pi_state(pi_state);\n\t\t\t\t/*\n\t\t\t\t * We stop queueing more waiters and let user\n\t\t\t\t * space deal with the mess.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}"}}
{"step": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);", "dataset1_info": {"data_index": 5331, "step_index": 29, "label": 0, "code": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);"}, "dataset2_info": {"data_index": 506, "step_index": 25, "label": 1, "code": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);"}}
{"step": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);", "dataset1_info": {"data_index": 5331, "step_index": 29, "label": 0, "code": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);"}, "dataset2_info": {"data_index": 506, "step_index": 25, "label": 1, "code": "\t/*\n\t * We took an extra initial reference to the pi_state either\n\t * in futex_proxy_trylock_atomic() or in lookup_pi_state(). We\n\t * need to drop it here again.\n\t */\n\tput_pi_state(pi_state);"}}
{"step": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);", "dataset1_info": {"data_index": 5331, "step_index": 30, "label": 0, "code": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 26, "label": 1, "code": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);"}}
{"step": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);", "dataset1_info": {"data_index": 5331, "step_index": 30, "label": 0, "code": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);"}, "dataset2_info": {"data_index": 506, "step_index": 26, "label": 1, "code": "out_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\thb_waiters_dec(hb2);"}}
{"step": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);", "dataset1_info": {"data_index": 5331, "step_index": 31, "label": 0, "code": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);"}, "dataset2_info": {"data_index": 506, "step_index": 27, "label": 1, "code": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);"}}
{"step": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);", "dataset1_info": {"data_index": 5331, "step_index": 31, "label": 0, "code": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);"}, "dataset2_info": {"data_index": 506, "step_index": 27, "label": 1, "code": "\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);"}}
{"step": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 6494, "step_index": 139, "label": 0, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 646, "step_index": 142, "label": 1, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}}
{"step": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 6494, "step_index": 139, "label": 0, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 646, "step_index": 142, "label": 1, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}}
{"step": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 6495, "step_index": 139, "label": 0, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 646, "step_index": 142, "label": 1, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}}
{"step": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");", "dataset1_info": {"data_index": 6495, "step_index": 139, "label": 0, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}, "dataset2_info": {"data_index": 646, "step_index": 142, "label": 1, "code": "            if (AcquireImageColormap(image,image_colors,exception) ==\n                MagickFalse)\n               ThrowWriterException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");"}}
{"step": "  Quantum\n    index;", "dataset1_info": {"data_index": 6561, "step_index": 9, "label": 0, "code": "  Quantum\n    index;"}, "dataset2_info": {"data_index": 408, "step_index": 7, "label": 1, "code": "  Quantum\n    index;"}}
{"step": "  Quantum\n    index;", "dataset1_info": {"data_index": 6561, "step_index": 9, "label": 0, "code": "  Quantum\n    index;"}, "dataset2_info": {"data_index": 408, "step_index": 7, "label": 1, "code": "  Quantum\n    index;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 394, "step_index": 6, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 394, "step_index": 6, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 408, "step_index": 9, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 408, "step_index": 9, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 426, "step_index": 4, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 426, "step_index": 4, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 463, "step_index": 2, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 463, "step_index": 2, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 498, "step_index": 2, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 498, "step_index": 2, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 602, "step_index": 8, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  register Quantum\n    *q;", "dataset1_info": {"data_index": 6561, "step_index": 10, "label": 0, "code": "  register Quantum\n    *q;"}, "dataset2_info": {"data_index": 602, "step_index": 8, "label": 1, "code": "  register Quantum\n    *q;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6563, "step_index": 3, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6563, "step_index": 3, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 477, "step_index": 1, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 477, "step_index": 1, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 514, "step_index": 2, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 514, "step_index": 2, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 646, "step_index": 5, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  const StringInfo\n    *profile;", "dataset1_info": {"data_index": 6563, "step_index": 4, "label": 0, "code": "  const StringInfo\n    *profile;"}, "dataset2_info": {"data_index": 646, "step_index": 5, "label": 1, "code": "  const StringInfo\n    *profile;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 428, "step_index": 3, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 428, "step_index": 3, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 514, "step_index": 6, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 514, "step_index": 6, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 688, "step_index": 3, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "  register const Quantum\n    *p;", "dataset1_info": {"data_index": 6563, "step_index": 11, "label": 0, "code": "  register const Quantum\n    *p;"}, "dataset2_info": {"data_index": 688, "step_index": 3, "label": 1, "code": "  register const Quantum\n    *p;"}}
{"step": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;", "dataset1_info": {"data_index": 6563, "step_index": 59, "label": 0, "code": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;"}, "dataset2_info": {"data_index": 514, "step_index": 21, "label": 1, "code": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;"}}
{"step": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;", "dataset1_info": {"data_index": 6563, "step_index": 59, "label": 0, "code": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;"}, "dataset2_info": {"data_index": 514, "step_index": 21, "label": 1, "code": "        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;"}}
{"step": "        ssize_t\n          offset;", "dataset1_info": {"data_index": 6563, "step_index": 67, "label": 0, "code": "        ssize_t\n          offset;"}, "dataset2_info": {"data_index": 514, "step_index": 23, "label": 1, "code": "        ssize_t\n          offset;"}}
{"step": "        ssize_t\n          offset;", "dataset1_info": {"data_index": 6563, "step_index": 67, "label": 0, "code": "        ssize_t\n          offset;"}, "dataset2_info": {"data_index": 514, "step_index": 23, "label": 1, "code": "        ssize_t\n          offset;"}}
{"step": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;", "dataset1_info": {"data_index": 6563, "step_index": 89, "label": 0, "code": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;"}, "dataset2_info": {"data_index": 514, "step_index": 26, "label": 1, "code": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;"}}
{"step": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;", "dataset1_info": {"data_index": 6563, "step_index": 89, "label": 0, "code": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;"}, "dataset2_info": {"data_index": 514, "step_index": 26, "label": 1, "code": "            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6587, "step_index": 7, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6587, "step_index": 7, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6587, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6587, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 426, "step_index": 10, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 426, "step_index": 10, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 453, "step_index": 19, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 453, "step_index": 19, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 472, "step_index": 13, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 472, "step_index": 13, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 688, "step_index": 6, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6587, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 688, "step_index": 6, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 375, "step_index": 16, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 375, "step_index": 16, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 12, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 22, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 12, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 22, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 417, "step_index": 14, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6587, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 417, "step_index": 14, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;", "dataset1_info": {"data_index": 6840, "step_index": 3, "label": 0, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}, "dataset2_info": {"data_index": 555, "step_index": 1, "label": 1, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}}
{"step": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;", "dataset1_info": {"data_index": 6840, "step_index": 3, "label": 0, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}, "dataset2_info": {"data_index": 555, "step_index": 1, "label": 1, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}}
{"step": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;", "dataset1_info": {"data_index": 6841, "step_index": 3, "label": 0, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}, "dataset2_info": {"data_index": 555, "step_index": 1, "label": 1, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}}
{"step": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;", "dataset1_info": {"data_index": 6841, "step_index": 3, "label": 0, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}, "dataset2_info": {"data_index": 555, "step_index": 1, "label": 1, "code": "  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6921, "step_index": 7, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  const char\n    *option;", "dataset1_info": {"data_index": 6921, "step_index": 7, "label": 0, "code": "  const char\n    *option;"}, "dataset2_info": {"data_index": 514, "step_index": 1, "label": 1, "code": "  const char\n    *option;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 6921, "step_index": 12, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 394, "step_index": 8, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 408, "step_index": 11, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 426, "step_index": 6, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 453, "step_index": 16, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 471, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  register unsigned char\n    *p;", "dataset1_info": {"data_index": 6921, "step_index": 24, "label": 0, "code": "  register unsigned char\n    *p;"}, "dataset2_info": {"data_index": 602, "step_index": 9, "label": 1, "code": "  register unsigned char\n    *p;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 426, "step_index": 10, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 426, "step_index": 10, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 453, "step_index": 19, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 453, "step_index": 19, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 472, "step_index": 13, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 472, "step_index": 13, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 688, "step_index": 6, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "  unsigned char\n    *pixels;", "dataset1_info": {"data_index": 6921, "step_index": 27, "label": 0, "code": "  unsigned char\n    *pixels;"}, "dataset2_info": {"data_index": 688, "step_index": 6, "label": 1, "code": "  unsigned char\n    *pixels;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 375, "step_index": 16, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 375, "step_index": 16, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 12, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 22, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 12, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 414, "step_index": 22, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 417, "step_index": 14, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "    register ssize_t\n      x;", "dataset1_info": {"data_index": 6921, "step_index": 41, "label": 0, "code": "    register ssize_t\n      x;"}, "dataset2_info": {"data_index": 417, "step_index": 14, "label": 1, "code": "    register ssize_t\n      x;"}}
{"step": "  IndexPacket\n    index;", "dataset1_info": {"data_index": 7081, "step_index": 3, "label": 0, "code": "  IndexPacket\n    index;"}, "dataset2_info": {"data_index": 716, "step_index": 4, "label": 1, "code": "  IndexPacket\n    index;"}}
{"step": "  IndexPacket\n    index;", "dataset1_info": {"data_index": 7081, "step_index": 3, "label": 0, "code": "  IndexPacket\n    index;"}, "dataset2_info": {"data_index": 716, "step_index": 4, "label": 1, "code": "  IndexPacket\n    index;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 408, "step_index": 6, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 426, "step_index": 3, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  MemoryInfo\n    *pixel_info;", "dataset1_info": {"data_index": 7081, "step_index": 6, "label": 0, "code": "  MemoryInfo\n    *pixel_info;"}, "dataset2_info": {"data_index": 514, "step_index": 5, "label": 1, "code": "  MemoryInfo\n    *pixel_info;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 408, "step_index": 10, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 408, "step_index": 10, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 412, "step_index": 6, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 412, "step_index": 6, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 453, "step_index": 15, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 453, "step_index": 15, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 471, "step_index": 10, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 471, "step_index": 10, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 472, "step_index": 7, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 472, "step_index": 7, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 477, "step_index": 5, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 477, "step_index": 5, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 688, "step_index": 4, "label": 1, "code": "  register ssize_t\n    i;"}}
{"step": "  register ssize_t\n    i;", "dataset1_info": {"data_index": 7081, "step_index": 15, "label": 0, "code": "  register ssize_t\n    i;"}, "dataset2_info": {"data_index": 688, "step_index": 4, "label": 1, "code": "  register ssize_t\n    i;"}}
